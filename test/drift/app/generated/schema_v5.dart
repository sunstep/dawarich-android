// dart format width=80
// GENERATED BY drift_dev, DO NOT MODIFY.
// ignore_for_file: type=lint,unused_import
//
import 'package:drift/drift.dart';

class UserTable extends Table with TableInfo<UserTable, UserTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  UserTable(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  late final GeneratedColumn<int> dawarichId = GeneratedColumn<int>(
      'dawarich_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  late final GeneratedColumn<String> dawarichEndpoint = GeneratedColumn<String>(
      'dawarich_endpoint', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
      'email', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  late final GeneratedColumn<String> theme = GeneratedColumn<String>(
      'theme', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  late final GeneratedColumn<bool> admin = GeneratedColumn<bool>(
      'admin', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("admin" IN (0, 1))'));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        dawarichId,
        dawarichEndpoint,
        email,
        createdAt,
        updatedAt,
        theme,
        admin
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user_table';
  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {dawarichId, dawarichEndpoint},
      ];
  @override
  UserTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      dawarichId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}dawarich_id']),
      dawarichEndpoint: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}dawarich_endpoint']),
      email: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at']),
      theme: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}theme'])!,
      admin: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}admin'])!,
    );
  }

  @override
  UserTable createAlias(String alias) {
    return UserTable(attachedDatabase, alias);
  }
}

class UserTableData extends DataClass implements Insertable<UserTableData> {
  final int id;
  final int? dawarichId;
  final String? dawarichEndpoint;
  final String email;
  final DateTime createdAt;
  final DateTime? updatedAt;
  final String theme;
  final bool admin;
  const UserTableData(
      {required this.id,
      this.dawarichId,
      this.dawarichEndpoint,
      required this.email,
      required this.createdAt,
      this.updatedAt,
      required this.theme,
      required this.admin});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || dawarichId != null) {
      map['dawarich_id'] = Variable<int>(dawarichId);
    }
    if (!nullToAbsent || dawarichEndpoint != null) {
      map['dawarich_endpoint'] = Variable<String>(dawarichEndpoint);
    }
    map['email'] = Variable<String>(email);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || updatedAt != null) {
      map['updated_at'] = Variable<DateTime>(updatedAt);
    }
    map['theme'] = Variable<String>(theme);
    map['admin'] = Variable<bool>(admin);
    return map;
  }

  UserTableCompanion toCompanion(bool nullToAbsent) {
    return UserTableCompanion(
      id: Value(id),
      dawarichId: dawarichId == null && nullToAbsent
          ? const Value.absent()
          : Value(dawarichId),
      dawarichEndpoint: dawarichEndpoint == null && nullToAbsent
          ? const Value.absent()
          : Value(dawarichEndpoint),
      email: Value(email),
      createdAt: Value(createdAt),
      updatedAt: updatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAt),
      theme: Value(theme),
      admin: Value(admin),
    );
  }

  factory UserTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserTableData(
      id: serializer.fromJson<int>(json['id']),
      dawarichId: serializer.fromJson<int?>(json['dawarichId']),
      dawarichEndpoint: serializer.fromJson<String?>(json['dawarichEndpoint']),
      email: serializer.fromJson<String>(json['email']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime?>(json['updatedAt']),
      theme: serializer.fromJson<String>(json['theme']),
      admin: serializer.fromJson<bool>(json['admin']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'dawarichId': serializer.toJson<int?>(dawarichId),
      'dawarichEndpoint': serializer.toJson<String?>(dawarichEndpoint),
      'email': serializer.toJson<String>(email),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime?>(updatedAt),
      'theme': serializer.toJson<String>(theme),
      'admin': serializer.toJson<bool>(admin),
    };
  }

  UserTableData copyWith(
          {int? id,
          Value<int?> dawarichId = const Value.absent(),
          Value<String?> dawarichEndpoint = const Value.absent(),
          String? email,
          DateTime? createdAt,
          Value<DateTime?> updatedAt = const Value.absent(),
          String? theme,
          bool? admin}) =>
      UserTableData(
        id: id ?? this.id,
        dawarichId: dawarichId.present ? dawarichId.value : this.dawarichId,
        dawarichEndpoint: dawarichEndpoint.present
            ? dawarichEndpoint.value
            : this.dawarichEndpoint,
        email: email ?? this.email,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt.present ? updatedAt.value : this.updatedAt,
        theme: theme ?? this.theme,
        admin: admin ?? this.admin,
      );
  UserTableData copyWithCompanion(UserTableCompanion data) {
    return UserTableData(
      id: data.id.present ? data.id.value : this.id,
      dawarichId:
          data.dawarichId.present ? data.dawarichId.value : this.dawarichId,
      dawarichEndpoint: data.dawarichEndpoint.present
          ? data.dawarichEndpoint.value
          : this.dawarichEndpoint,
      email: data.email.present ? data.email.value : this.email,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      theme: data.theme.present ? data.theme.value : this.theme,
      admin: data.admin.present ? data.admin.value : this.admin,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UserTableData(')
          ..write('id: $id, ')
          ..write('dawarichId: $dawarichId, ')
          ..write('dawarichEndpoint: $dawarichEndpoint, ')
          ..write('email: $email, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('theme: $theme, ')
          ..write('admin: $admin')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, dawarichId, dawarichEndpoint, email,
      createdAt, updatedAt, theme, admin);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserTableData &&
          other.id == this.id &&
          other.dawarichId == this.dawarichId &&
          other.dawarichEndpoint == this.dawarichEndpoint &&
          other.email == this.email &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.theme == this.theme &&
          other.admin == this.admin);
}

class UserTableCompanion extends UpdateCompanion<UserTableData> {
  final Value<int> id;
  final Value<int?> dawarichId;
  final Value<String?> dawarichEndpoint;
  final Value<String> email;
  final Value<DateTime> createdAt;
  final Value<DateTime?> updatedAt;
  final Value<String> theme;
  final Value<bool> admin;
  const UserTableCompanion({
    this.id = const Value.absent(),
    this.dawarichId = const Value.absent(),
    this.dawarichEndpoint = const Value.absent(),
    this.email = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.theme = const Value.absent(),
    this.admin = const Value.absent(),
  });
  UserTableCompanion.insert({
    this.id = const Value.absent(),
    this.dawarichId = const Value.absent(),
    this.dawarichEndpoint = const Value.absent(),
    required String email,
    required DateTime createdAt,
    this.updatedAt = const Value.absent(),
    required String theme,
    required bool admin,
  })  : email = Value(email),
        createdAt = Value(createdAt),
        theme = Value(theme),
        admin = Value(admin);
  static Insertable<UserTableData> custom({
    Expression<int>? id,
    Expression<int>? dawarichId,
    Expression<String>? dawarichEndpoint,
    Expression<String>? email,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<String>? theme,
    Expression<bool>? admin,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (dawarichId != null) 'dawarich_id': dawarichId,
      if (dawarichEndpoint != null) 'dawarich_endpoint': dawarichEndpoint,
      if (email != null) 'email': email,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (theme != null) 'theme': theme,
      if (admin != null) 'admin': admin,
    });
  }

  UserTableCompanion copyWith(
      {Value<int>? id,
      Value<int?>? dawarichId,
      Value<String?>? dawarichEndpoint,
      Value<String>? email,
      Value<DateTime>? createdAt,
      Value<DateTime?>? updatedAt,
      Value<String>? theme,
      Value<bool>? admin}) {
    return UserTableCompanion(
      id: id ?? this.id,
      dawarichId: dawarichId ?? this.dawarichId,
      dawarichEndpoint: dawarichEndpoint ?? this.dawarichEndpoint,
      email: email ?? this.email,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      theme: theme ?? this.theme,
      admin: admin ?? this.admin,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (dawarichId.present) {
      map['dawarich_id'] = Variable<int>(dawarichId.value);
    }
    if (dawarichEndpoint.present) {
      map['dawarich_endpoint'] = Variable<String>(dawarichEndpoint.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (theme.present) {
      map['theme'] = Variable<String>(theme.value);
    }
    if (admin.present) {
      map['admin'] = Variable<bool>(admin.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserTableCompanion(')
          ..write('id: $id, ')
          ..write('dawarichId: $dawarichId, ')
          ..write('dawarichEndpoint: $dawarichEndpoint, ')
          ..write('email: $email, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('theme: $theme, ')
          ..write('admin: $admin')
          ..write(')'))
        .toString();
  }
}

class UserSettingsTable extends Table
    with TableInfo<UserSettingsTable, UserSettingsTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  UserSettingsTable(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  late final GeneratedColumn<int> userId = GeneratedColumn<int>(
      'user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES user_table (id)'));
  late final GeneratedColumn<String> immichUrl = GeneratedColumn<String>(
      'immich_url', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  late final GeneratedColumn<String> immichApiKey = GeneratedColumn<String>(
      'immich_api_key', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  late final GeneratedColumn<String> photoprismUrl = GeneratedColumn<String>(
      'photoprism_url', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  late final GeneratedColumn<String> photoprismApiKey = GeneratedColumn<String>(
      'photoprism_api_key', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  late final GeneratedColumn<String> distanceUnit = GeneratedColumn<String>(
      'distance_unit', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  late final GeneratedColumn<int> fogOfWarMeters = GeneratedColumn<int>(
      'fog_of_war_meters', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  late final GeneratedColumn<int> metersBetweenRoutes = GeneratedColumn<int>(
      'meters_between_routes', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  late final GeneratedColumn<String> preferredMapLayer =
      GeneratedColumn<String>('preferred_map_layer', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  late final GeneratedColumn<bool> speedColoredRoutes = GeneratedColumn<bool>(
      'speed_colored_routes', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("speed_colored_routes" IN (0, 1))'));
  late final GeneratedColumn<String> pointsRenderingMode =
      GeneratedColumn<String>('points_rendering_mode', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  late final GeneratedColumn<int> minutesBetweenRoutes = GeneratedColumn<int>(
      'minutes_between_routes', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  late final GeneratedColumn<int> timeThresholdMinutes = GeneratedColumn<int>(
      'time_threshold_minutes', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  late final GeneratedColumn<int> mergeThresholdMinutes = GeneratedColumn<int>(
      'merge_threshold_minutes', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  late final GeneratedColumn<bool> liveMapEnabled = GeneratedColumn<bool>(
      'live_map_enabled', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("live_map_enabled" IN (0, 1))'));
  late final GeneratedColumn<double> routeOpacity = GeneratedColumn<double>(
      'route_opacity', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  late final GeneratedColumn<bool> visitsSuggestionsEnabled =
      GeneratedColumn<bool>(
          'visits_suggestions_enabled', aliasedName, true,
          type: DriftSqlType.bool,
          requiredDuringInsert: false,
          defaultConstraints: GeneratedColumn.constraintIsAlways(
              'CHECK ("visits_suggestions_enabled" IN (0, 1))'));
  late final GeneratedColumn<String> speedColorScale = GeneratedColumn<String>(
      'speed_color_scale', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  late final GeneratedColumn<int> fogOfWarThreshold = GeneratedColumn<int>(
      'fog_of_war_threshold', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        userId,
        immichUrl,
        immichApiKey,
        photoprismUrl,
        photoprismApiKey,
        distanceUnit,
        fogOfWarMeters,
        metersBetweenRoutes,
        preferredMapLayer,
        speedColoredRoutes,
        pointsRenderingMode,
        minutesBetweenRoutes,
        timeThresholdMinutes,
        mergeThresholdMinutes,
        liveMapEnabled,
        routeOpacity,
        visitsSuggestionsEnabled,
        speedColorScale,
        fogOfWarThreshold
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user_settings_table';
  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UserSettingsTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserSettingsTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}user_id'])!,
      immichUrl: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}immich_url']),
      immichApiKey: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}immich_api_key']),
      photoprismUrl: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}photoprism_url']),
      photoprismApiKey: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}photoprism_api_key']),
      distanceUnit: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}distance_unit']),
      fogOfWarMeters: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}fog_of_war_meters']),
      metersBetweenRoutes: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}meters_between_routes']),
      preferredMapLayer: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}preferred_map_layer']),
      speedColoredRoutes: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}speed_colored_routes']),
      pointsRenderingMode: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}points_rendering_mode']),
      minutesBetweenRoutes: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}minutes_between_routes']),
      timeThresholdMinutes: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}time_threshold_minutes']),
      mergeThresholdMinutes: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}merge_threshold_minutes']),
      liveMapEnabled: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}live_map_enabled']),
      routeOpacity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}route_opacity']),
      visitsSuggestionsEnabled: attachedDatabase.typeMapping.read(
          DriftSqlType.bool,
          data['${effectivePrefix}visits_suggestions_enabled']),
      speedColorScale: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}speed_color_scale']),
      fogOfWarThreshold: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}fog_of_war_threshold']),
    );
  }

  @override
  UserSettingsTable createAlias(String alias) {
    return UserSettingsTable(attachedDatabase, alias);
  }
}

class UserSettingsTableData extends DataClass
    implements Insertable<UserSettingsTableData> {
  final int id;
  final int userId;
  final String? immichUrl;
  final String? immichApiKey;
  final String? photoprismUrl;
  final String? photoprismApiKey;
  final String? distanceUnit;
  final int? fogOfWarMeters;
  final int? metersBetweenRoutes;
  final String? preferredMapLayer;
  final bool? speedColoredRoutes;
  final String? pointsRenderingMode;
  final int? minutesBetweenRoutes;
  final int? timeThresholdMinutes;
  final int? mergeThresholdMinutes;
  final bool? liveMapEnabled;
  final double? routeOpacity;
  final bool? visitsSuggestionsEnabled;
  final String? speedColorScale;
  final int? fogOfWarThreshold;
  const UserSettingsTableData(
      {required this.id,
      required this.userId,
      this.immichUrl,
      this.immichApiKey,
      this.photoprismUrl,
      this.photoprismApiKey,
      this.distanceUnit,
      this.fogOfWarMeters,
      this.metersBetweenRoutes,
      this.preferredMapLayer,
      this.speedColoredRoutes,
      this.pointsRenderingMode,
      this.minutesBetweenRoutes,
      this.timeThresholdMinutes,
      this.mergeThresholdMinutes,
      this.liveMapEnabled,
      this.routeOpacity,
      this.visitsSuggestionsEnabled,
      this.speedColorScale,
      this.fogOfWarThreshold});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['user_id'] = Variable<int>(userId);
    if (!nullToAbsent || immichUrl != null) {
      map['immich_url'] = Variable<String>(immichUrl);
    }
    if (!nullToAbsent || immichApiKey != null) {
      map['immich_api_key'] = Variable<String>(immichApiKey);
    }
    if (!nullToAbsent || photoprismUrl != null) {
      map['photoprism_url'] = Variable<String>(photoprismUrl);
    }
    if (!nullToAbsent || photoprismApiKey != null) {
      map['photoprism_api_key'] = Variable<String>(photoprismApiKey);
    }
    if (!nullToAbsent || distanceUnit != null) {
      map['distance_unit'] = Variable<String>(distanceUnit);
    }
    if (!nullToAbsent || fogOfWarMeters != null) {
      map['fog_of_war_meters'] = Variable<int>(fogOfWarMeters);
    }
    if (!nullToAbsent || metersBetweenRoutes != null) {
      map['meters_between_routes'] = Variable<int>(metersBetweenRoutes);
    }
    if (!nullToAbsent || preferredMapLayer != null) {
      map['preferred_map_layer'] = Variable<String>(preferredMapLayer);
    }
    if (!nullToAbsent || speedColoredRoutes != null) {
      map['speed_colored_routes'] = Variable<bool>(speedColoredRoutes);
    }
    if (!nullToAbsent || pointsRenderingMode != null) {
      map['points_rendering_mode'] = Variable<String>(pointsRenderingMode);
    }
    if (!nullToAbsent || minutesBetweenRoutes != null) {
      map['minutes_between_routes'] = Variable<int>(minutesBetweenRoutes);
    }
    if (!nullToAbsent || timeThresholdMinutes != null) {
      map['time_threshold_minutes'] = Variable<int>(timeThresholdMinutes);
    }
    if (!nullToAbsent || mergeThresholdMinutes != null) {
      map['merge_threshold_minutes'] = Variable<int>(mergeThresholdMinutes);
    }
    if (!nullToAbsent || liveMapEnabled != null) {
      map['live_map_enabled'] = Variable<bool>(liveMapEnabled);
    }
    if (!nullToAbsent || routeOpacity != null) {
      map['route_opacity'] = Variable<double>(routeOpacity);
    }
    if (!nullToAbsent || visitsSuggestionsEnabled != null) {
      map['visits_suggestions_enabled'] =
          Variable<bool>(visitsSuggestionsEnabled);
    }
    if (!nullToAbsent || speedColorScale != null) {
      map['speed_color_scale'] = Variable<String>(speedColorScale);
    }
    if (!nullToAbsent || fogOfWarThreshold != null) {
      map['fog_of_war_threshold'] = Variable<int>(fogOfWarThreshold);
    }
    return map;
  }

  UserSettingsTableCompanion toCompanion(bool nullToAbsent) {
    return UserSettingsTableCompanion(
      id: Value(id),
      userId: Value(userId),
      immichUrl: immichUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(immichUrl),
      immichApiKey: immichApiKey == null && nullToAbsent
          ? const Value.absent()
          : Value(immichApiKey),
      photoprismUrl: photoprismUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(photoprismUrl),
      photoprismApiKey: photoprismApiKey == null && nullToAbsent
          ? const Value.absent()
          : Value(photoprismApiKey),
      distanceUnit: distanceUnit == null && nullToAbsent
          ? const Value.absent()
          : Value(distanceUnit),
      fogOfWarMeters: fogOfWarMeters == null && nullToAbsent
          ? const Value.absent()
          : Value(fogOfWarMeters),
      metersBetweenRoutes: metersBetweenRoutes == null && nullToAbsent
          ? const Value.absent()
          : Value(metersBetweenRoutes),
      preferredMapLayer: preferredMapLayer == null && nullToAbsent
          ? const Value.absent()
          : Value(preferredMapLayer),
      speedColoredRoutes: speedColoredRoutes == null && nullToAbsent
          ? const Value.absent()
          : Value(speedColoredRoutes),
      pointsRenderingMode: pointsRenderingMode == null && nullToAbsent
          ? const Value.absent()
          : Value(pointsRenderingMode),
      minutesBetweenRoutes: minutesBetweenRoutes == null && nullToAbsent
          ? const Value.absent()
          : Value(minutesBetweenRoutes),
      timeThresholdMinutes: timeThresholdMinutes == null && nullToAbsent
          ? const Value.absent()
          : Value(timeThresholdMinutes),
      mergeThresholdMinutes: mergeThresholdMinutes == null && nullToAbsent
          ? const Value.absent()
          : Value(mergeThresholdMinutes),
      liveMapEnabled: liveMapEnabled == null && nullToAbsent
          ? const Value.absent()
          : Value(liveMapEnabled),
      routeOpacity: routeOpacity == null && nullToAbsent
          ? const Value.absent()
          : Value(routeOpacity),
      visitsSuggestionsEnabled: visitsSuggestionsEnabled == null && nullToAbsent
          ? const Value.absent()
          : Value(visitsSuggestionsEnabled),
      speedColorScale: speedColorScale == null && nullToAbsent
          ? const Value.absent()
          : Value(speedColorScale),
      fogOfWarThreshold: fogOfWarThreshold == null && nullToAbsent
          ? const Value.absent()
          : Value(fogOfWarThreshold),
    );
  }

  factory UserSettingsTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserSettingsTableData(
      id: serializer.fromJson<int>(json['id']),
      userId: serializer.fromJson<int>(json['userId']),
      immichUrl: serializer.fromJson<String?>(json['immichUrl']),
      immichApiKey: serializer.fromJson<String?>(json['immichApiKey']),
      photoprismUrl: serializer.fromJson<String?>(json['photoprismUrl']),
      photoprismApiKey: serializer.fromJson<String?>(json['photoprismApiKey']),
      distanceUnit: serializer.fromJson<String?>(json['distanceUnit']),
      fogOfWarMeters: serializer.fromJson<int?>(json['fogOfWarMeters']),
      metersBetweenRoutes:
          serializer.fromJson<int?>(json['metersBetweenRoutes']),
      preferredMapLayer:
          serializer.fromJson<String?>(json['preferredMapLayer']),
      speedColoredRoutes:
          serializer.fromJson<bool?>(json['speedColoredRoutes']),
      pointsRenderingMode:
          serializer.fromJson<String?>(json['pointsRenderingMode']),
      minutesBetweenRoutes:
          serializer.fromJson<int?>(json['minutesBetweenRoutes']),
      timeThresholdMinutes:
          serializer.fromJson<int?>(json['timeThresholdMinutes']),
      mergeThresholdMinutes:
          serializer.fromJson<int?>(json['mergeThresholdMinutes']),
      liveMapEnabled: serializer.fromJson<bool?>(json['liveMapEnabled']),
      routeOpacity: serializer.fromJson<double?>(json['routeOpacity']),
      visitsSuggestionsEnabled:
          serializer.fromJson<bool?>(json['visitsSuggestionsEnabled']),
      speedColorScale: serializer.fromJson<String?>(json['speedColorScale']),
      fogOfWarThreshold: serializer.fromJson<int?>(json['fogOfWarThreshold']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'userId': serializer.toJson<int>(userId),
      'immichUrl': serializer.toJson<String?>(immichUrl),
      'immichApiKey': serializer.toJson<String?>(immichApiKey),
      'photoprismUrl': serializer.toJson<String?>(photoprismUrl),
      'photoprismApiKey': serializer.toJson<String?>(photoprismApiKey),
      'distanceUnit': serializer.toJson<String?>(distanceUnit),
      'fogOfWarMeters': serializer.toJson<int?>(fogOfWarMeters),
      'metersBetweenRoutes': serializer.toJson<int?>(metersBetweenRoutes),
      'preferredMapLayer': serializer.toJson<String?>(preferredMapLayer),
      'speedColoredRoutes': serializer.toJson<bool?>(speedColoredRoutes),
      'pointsRenderingMode': serializer.toJson<String?>(pointsRenderingMode),
      'minutesBetweenRoutes': serializer.toJson<int?>(minutesBetweenRoutes),
      'timeThresholdMinutes': serializer.toJson<int?>(timeThresholdMinutes),
      'mergeThresholdMinutes': serializer.toJson<int?>(mergeThresholdMinutes),
      'liveMapEnabled': serializer.toJson<bool?>(liveMapEnabled),
      'routeOpacity': serializer.toJson<double?>(routeOpacity),
      'visitsSuggestionsEnabled':
          serializer.toJson<bool?>(visitsSuggestionsEnabled),
      'speedColorScale': serializer.toJson<String?>(speedColorScale),
      'fogOfWarThreshold': serializer.toJson<int?>(fogOfWarThreshold),
    };
  }

  UserSettingsTableData copyWith(
          {int? id,
          int? userId,
          Value<String?> immichUrl = const Value.absent(),
          Value<String?> immichApiKey = const Value.absent(),
          Value<String?> photoprismUrl = const Value.absent(),
          Value<String?> photoprismApiKey = const Value.absent(),
          Value<String?> distanceUnit = const Value.absent(),
          Value<int?> fogOfWarMeters = const Value.absent(),
          Value<int?> metersBetweenRoutes = const Value.absent(),
          Value<String?> preferredMapLayer = const Value.absent(),
          Value<bool?> speedColoredRoutes = const Value.absent(),
          Value<String?> pointsRenderingMode = const Value.absent(),
          Value<int?> minutesBetweenRoutes = const Value.absent(),
          Value<int?> timeThresholdMinutes = const Value.absent(),
          Value<int?> mergeThresholdMinutes = const Value.absent(),
          Value<bool?> liveMapEnabled = const Value.absent(),
          Value<double?> routeOpacity = const Value.absent(),
          Value<bool?> visitsSuggestionsEnabled = const Value.absent(),
          Value<String?> speedColorScale = const Value.absent(),
          Value<int?> fogOfWarThreshold = const Value.absent()}) =>
      UserSettingsTableData(
        id: id ?? this.id,
        userId: userId ?? this.userId,
        immichUrl: immichUrl.present ? immichUrl.value : this.immichUrl,
        immichApiKey:
            immichApiKey.present ? immichApiKey.value : this.immichApiKey,
        photoprismUrl:
            photoprismUrl.present ? photoprismUrl.value : this.photoprismUrl,
        photoprismApiKey: photoprismApiKey.present
            ? photoprismApiKey.value
            : this.photoprismApiKey,
        distanceUnit:
            distanceUnit.present ? distanceUnit.value : this.distanceUnit,
        fogOfWarMeters:
            fogOfWarMeters.present ? fogOfWarMeters.value : this.fogOfWarMeters,
        metersBetweenRoutes: metersBetweenRoutes.present
            ? metersBetweenRoutes.value
            : this.metersBetweenRoutes,
        preferredMapLayer: preferredMapLayer.present
            ? preferredMapLayer.value
            : this.preferredMapLayer,
        speedColoredRoutes: speedColoredRoutes.present
            ? speedColoredRoutes.value
            : this.speedColoredRoutes,
        pointsRenderingMode: pointsRenderingMode.present
            ? pointsRenderingMode.value
            : this.pointsRenderingMode,
        minutesBetweenRoutes: minutesBetweenRoutes.present
            ? minutesBetweenRoutes.value
            : this.minutesBetweenRoutes,
        timeThresholdMinutes: timeThresholdMinutes.present
            ? timeThresholdMinutes.value
            : this.timeThresholdMinutes,
        mergeThresholdMinutes: mergeThresholdMinutes.present
            ? mergeThresholdMinutes.value
            : this.mergeThresholdMinutes,
        liveMapEnabled:
            liveMapEnabled.present ? liveMapEnabled.value : this.liveMapEnabled,
        routeOpacity:
            routeOpacity.present ? routeOpacity.value : this.routeOpacity,
        visitsSuggestionsEnabled: visitsSuggestionsEnabled.present
            ? visitsSuggestionsEnabled.value
            : this.visitsSuggestionsEnabled,
        speedColorScale: speedColorScale.present
            ? speedColorScale.value
            : this.speedColorScale,
        fogOfWarThreshold: fogOfWarThreshold.present
            ? fogOfWarThreshold.value
            : this.fogOfWarThreshold,
      );
  UserSettingsTableData copyWithCompanion(UserSettingsTableCompanion data) {
    return UserSettingsTableData(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      immichUrl: data.immichUrl.present ? data.immichUrl.value : this.immichUrl,
      immichApiKey: data.immichApiKey.present
          ? data.immichApiKey.value
          : this.immichApiKey,
      photoprismUrl: data.photoprismUrl.present
          ? data.photoprismUrl.value
          : this.photoprismUrl,
      photoprismApiKey: data.photoprismApiKey.present
          ? data.photoprismApiKey.value
          : this.photoprismApiKey,
      distanceUnit: data.distanceUnit.present
          ? data.distanceUnit.value
          : this.distanceUnit,
      fogOfWarMeters: data.fogOfWarMeters.present
          ? data.fogOfWarMeters.value
          : this.fogOfWarMeters,
      metersBetweenRoutes: data.metersBetweenRoutes.present
          ? data.metersBetweenRoutes.value
          : this.metersBetweenRoutes,
      preferredMapLayer: data.preferredMapLayer.present
          ? data.preferredMapLayer.value
          : this.preferredMapLayer,
      speedColoredRoutes: data.speedColoredRoutes.present
          ? data.speedColoredRoutes.value
          : this.speedColoredRoutes,
      pointsRenderingMode: data.pointsRenderingMode.present
          ? data.pointsRenderingMode.value
          : this.pointsRenderingMode,
      minutesBetweenRoutes: data.minutesBetweenRoutes.present
          ? data.minutesBetweenRoutes.value
          : this.minutesBetweenRoutes,
      timeThresholdMinutes: data.timeThresholdMinutes.present
          ? data.timeThresholdMinutes.value
          : this.timeThresholdMinutes,
      mergeThresholdMinutes: data.mergeThresholdMinutes.present
          ? data.mergeThresholdMinutes.value
          : this.mergeThresholdMinutes,
      liveMapEnabled: data.liveMapEnabled.present
          ? data.liveMapEnabled.value
          : this.liveMapEnabled,
      routeOpacity: data.routeOpacity.present
          ? data.routeOpacity.value
          : this.routeOpacity,
      visitsSuggestionsEnabled: data.visitsSuggestionsEnabled.present
          ? data.visitsSuggestionsEnabled.value
          : this.visitsSuggestionsEnabled,
      speedColorScale: data.speedColorScale.present
          ? data.speedColorScale.value
          : this.speedColorScale,
      fogOfWarThreshold: data.fogOfWarThreshold.present
          ? data.fogOfWarThreshold.value
          : this.fogOfWarThreshold,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UserSettingsTableData(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('immichUrl: $immichUrl, ')
          ..write('immichApiKey: $immichApiKey, ')
          ..write('photoprismUrl: $photoprismUrl, ')
          ..write('photoprismApiKey: $photoprismApiKey, ')
          ..write('distanceUnit: $distanceUnit, ')
          ..write('fogOfWarMeters: $fogOfWarMeters, ')
          ..write('metersBetweenRoutes: $metersBetweenRoutes, ')
          ..write('preferredMapLayer: $preferredMapLayer, ')
          ..write('speedColoredRoutes: $speedColoredRoutes, ')
          ..write('pointsRenderingMode: $pointsRenderingMode, ')
          ..write('minutesBetweenRoutes: $minutesBetweenRoutes, ')
          ..write('timeThresholdMinutes: $timeThresholdMinutes, ')
          ..write('mergeThresholdMinutes: $mergeThresholdMinutes, ')
          ..write('liveMapEnabled: $liveMapEnabled, ')
          ..write('routeOpacity: $routeOpacity, ')
          ..write('visitsSuggestionsEnabled: $visitsSuggestionsEnabled, ')
          ..write('speedColorScale: $speedColorScale, ')
          ..write('fogOfWarThreshold: $fogOfWarThreshold')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      userId,
      immichUrl,
      immichApiKey,
      photoprismUrl,
      photoprismApiKey,
      distanceUnit,
      fogOfWarMeters,
      metersBetweenRoutes,
      preferredMapLayer,
      speedColoredRoutes,
      pointsRenderingMode,
      minutesBetweenRoutes,
      timeThresholdMinutes,
      mergeThresholdMinutes,
      liveMapEnabled,
      routeOpacity,
      visitsSuggestionsEnabled,
      speedColorScale,
      fogOfWarThreshold);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserSettingsTableData &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.immichUrl == this.immichUrl &&
          other.immichApiKey == this.immichApiKey &&
          other.photoprismUrl == this.photoprismUrl &&
          other.photoprismApiKey == this.photoprismApiKey &&
          other.distanceUnit == this.distanceUnit &&
          other.fogOfWarMeters == this.fogOfWarMeters &&
          other.metersBetweenRoutes == this.metersBetweenRoutes &&
          other.preferredMapLayer == this.preferredMapLayer &&
          other.speedColoredRoutes == this.speedColoredRoutes &&
          other.pointsRenderingMode == this.pointsRenderingMode &&
          other.minutesBetweenRoutes == this.minutesBetweenRoutes &&
          other.timeThresholdMinutes == this.timeThresholdMinutes &&
          other.mergeThresholdMinutes == this.mergeThresholdMinutes &&
          other.liveMapEnabled == this.liveMapEnabled &&
          other.routeOpacity == this.routeOpacity &&
          other.visitsSuggestionsEnabled == this.visitsSuggestionsEnabled &&
          other.speedColorScale == this.speedColorScale &&
          other.fogOfWarThreshold == this.fogOfWarThreshold);
}

class UserSettingsTableCompanion
    extends UpdateCompanion<UserSettingsTableData> {
  final Value<int> id;
  final Value<int> userId;
  final Value<String?> immichUrl;
  final Value<String?> immichApiKey;
  final Value<String?> photoprismUrl;
  final Value<String?> photoprismApiKey;
  final Value<String?> distanceUnit;
  final Value<int?> fogOfWarMeters;
  final Value<int?> metersBetweenRoutes;
  final Value<String?> preferredMapLayer;
  final Value<bool?> speedColoredRoutes;
  final Value<String?> pointsRenderingMode;
  final Value<int?> minutesBetweenRoutes;
  final Value<int?> timeThresholdMinutes;
  final Value<int?> mergeThresholdMinutes;
  final Value<bool?> liveMapEnabled;
  final Value<double?> routeOpacity;
  final Value<bool?> visitsSuggestionsEnabled;
  final Value<String?> speedColorScale;
  final Value<int?> fogOfWarThreshold;
  const UserSettingsTableCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.immichUrl = const Value.absent(),
    this.immichApiKey = const Value.absent(),
    this.photoprismUrl = const Value.absent(),
    this.photoprismApiKey = const Value.absent(),
    this.distanceUnit = const Value.absent(),
    this.fogOfWarMeters = const Value.absent(),
    this.metersBetweenRoutes = const Value.absent(),
    this.preferredMapLayer = const Value.absent(),
    this.speedColoredRoutes = const Value.absent(),
    this.pointsRenderingMode = const Value.absent(),
    this.minutesBetweenRoutes = const Value.absent(),
    this.timeThresholdMinutes = const Value.absent(),
    this.mergeThresholdMinutes = const Value.absent(),
    this.liveMapEnabled = const Value.absent(),
    this.routeOpacity = const Value.absent(),
    this.visitsSuggestionsEnabled = const Value.absent(),
    this.speedColorScale = const Value.absent(),
    this.fogOfWarThreshold = const Value.absent(),
  });
  UserSettingsTableCompanion.insert({
    this.id = const Value.absent(),
    required int userId,
    this.immichUrl = const Value.absent(),
    this.immichApiKey = const Value.absent(),
    this.photoprismUrl = const Value.absent(),
    this.photoprismApiKey = const Value.absent(),
    this.distanceUnit = const Value.absent(),
    this.fogOfWarMeters = const Value.absent(),
    this.metersBetweenRoutes = const Value.absent(),
    this.preferredMapLayer = const Value.absent(),
    this.speedColoredRoutes = const Value.absent(),
    this.pointsRenderingMode = const Value.absent(),
    this.minutesBetweenRoutes = const Value.absent(),
    this.timeThresholdMinutes = const Value.absent(),
    this.mergeThresholdMinutes = const Value.absent(),
    this.liveMapEnabled = const Value.absent(),
    this.routeOpacity = const Value.absent(),
    this.visitsSuggestionsEnabled = const Value.absent(),
    this.speedColorScale = const Value.absent(),
    this.fogOfWarThreshold = const Value.absent(),
  }) : userId = Value(userId);
  static Insertable<UserSettingsTableData> custom({
    Expression<int>? id,
    Expression<int>? userId,
    Expression<String>? immichUrl,
    Expression<String>? immichApiKey,
    Expression<String>? photoprismUrl,
    Expression<String>? photoprismApiKey,
    Expression<String>? distanceUnit,
    Expression<int>? fogOfWarMeters,
    Expression<int>? metersBetweenRoutes,
    Expression<String>? preferredMapLayer,
    Expression<bool>? speedColoredRoutes,
    Expression<String>? pointsRenderingMode,
    Expression<int>? minutesBetweenRoutes,
    Expression<int>? timeThresholdMinutes,
    Expression<int>? mergeThresholdMinutes,
    Expression<bool>? liveMapEnabled,
    Expression<double>? routeOpacity,
    Expression<bool>? visitsSuggestionsEnabled,
    Expression<String>? speedColorScale,
    Expression<int>? fogOfWarThreshold,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (immichUrl != null) 'immich_url': immichUrl,
      if (immichApiKey != null) 'immich_api_key': immichApiKey,
      if (photoprismUrl != null) 'photoprism_url': photoprismUrl,
      if (photoprismApiKey != null) 'photoprism_api_key': photoprismApiKey,
      if (distanceUnit != null) 'distance_unit': distanceUnit,
      if (fogOfWarMeters != null) 'fog_of_war_meters': fogOfWarMeters,
      if (metersBetweenRoutes != null)
        'meters_between_routes': metersBetweenRoutes,
      if (preferredMapLayer != null) 'preferred_map_layer': preferredMapLayer,
      if (speedColoredRoutes != null)
        'speed_colored_routes': speedColoredRoutes,
      if (pointsRenderingMode != null)
        'points_rendering_mode': pointsRenderingMode,
      if (minutesBetweenRoutes != null)
        'minutes_between_routes': minutesBetweenRoutes,
      if (timeThresholdMinutes != null)
        'time_threshold_minutes': timeThresholdMinutes,
      if (mergeThresholdMinutes != null)
        'merge_threshold_minutes': mergeThresholdMinutes,
      if (liveMapEnabled != null) 'live_map_enabled': liveMapEnabled,
      if (routeOpacity != null) 'route_opacity': routeOpacity,
      if (visitsSuggestionsEnabled != null)
        'visits_suggestions_enabled': visitsSuggestionsEnabled,
      if (speedColorScale != null) 'speed_color_scale': speedColorScale,
      if (fogOfWarThreshold != null) 'fog_of_war_threshold': fogOfWarThreshold,
    });
  }

  UserSettingsTableCompanion copyWith(
      {Value<int>? id,
      Value<int>? userId,
      Value<String?>? immichUrl,
      Value<String?>? immichApiKey,
      Value<String?>? photoprismUrl,
      Value<String?>? photoprismApiKey,
      Value<String?>? distanceUnit,
      Value<int?>? fogOfWarMeters,
      Value<int?>? metersBetweenRoutes,
      Value<String?>? preferredMapLayer,
      Value<bool?>? speedColoredRoutes,
      Value<String?>? pointsRenderingMode,
      Value<int?>? minutesBetweenRoutes,
      Value<int?>? timeThresholdMinutes,
      Value<int?>? mergeThresholdMinutes,
      Value<bool?>? liveMapEnabled,
      Value<double?>? routeOpacity,
      Value<bool?>? visitsSuggestionsEnabled,
      Value<String?>? speedColorScale,
      Value<int?>? fogOfWarThreshold}) {
    return UserSettingsTableCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      immichUrl: immichUrl ?? this.immichUrl,
      immichApiKey: immichApiKey ?? this.immichApiKey,
      photoprismUrl: photoprismUrl ?? this.photoprismUrl,
      photoprismApiKey: photoprismApiKey ?? this.photoprismApiKey,
      distanceUnit: distanceUnit ?? this.distanceUnit,
      fogOfWarMeters: fogOfWarMeters ?? this.fogOfWarMeters,
      metersBetweenRoutes: metersBetweenRoutes ?? this.metersBetweenRoutes,
      preferredMapLayer: preferredMapLayer ?? this.preferredMapLayer,
      speedColoredRoutes: speedColoredRoutes ?? this.speedColoredRoutes,
      pointsRenderingMode: pointsRenderingMode ?? this.pointsRenderingMode,
      minutesBetweenRoutes: minutesBetweenRoutes ?? this.minutesBetweenRoutes,
      timeThresholdMinutes: timeThresholdMinutes ?? this.timeThresholdMinutes,
      mergeThresholdMinutes:
          mergeThresholdMinutes ?? this.mergeThresholdMinutes,
      liveMapEnabled: liveMapEnabled ?? this.liveMapEnabled,
      routeOpacity: routeOpacity ?? this.routeOpacity,
      visitsSuggestionsEnabled:
          visitsSuggestionsEnabled ?? this.visitsSuggestionsEnabled,
      speedColorScale: speedColorScale ?? this.speedColorScale,
      fogOfWarThreshold: fogOfWarThreshold ?? this.fogOfWarThreshold,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    if (immichUrl.present) {
      map['immich_url'] = Variable<String>(immichUrl.value);
    }
    if (immichApiKey.present) {
      map['immich_api_key'] = Variable<String>(immichApiKey.value);
    }
    if (photoprismUrl.present) {
      map['photoprism_url'] = Variable<String>(photoprismUrl.value);
    }
    if (photoprismApiKey.present) {
      map['photoprism_api_key'] = Variable<String>(photoprismApiKey.value);
    }
    if (distanceUnit.present) {
      map['distance_unit'] = Variable<String>(distanceUnit.value);
    }
    if (fogOfWarMeters.present) {
      map['fog_of_war_meters'] = Variable<int>(fogOfWarMeters.value);
    }
    if (metersBetweenRoutes.present) {
      map['meters_between_routes'] = Variable<int>(metersBetweenRoutes.value);
    }
    if (preferredMapLayer.present) {
      map['preferred_map_layer'] = Variable<String>(preferredMapLayer.value);
    }
    if (speedColoredRoutes.present) {
      map['speed_colored_routes'] = Variable<bool>(speedColoredRoutes.value);
    }
    if (pointsRenderingMode.present) {
      map['points_rendering_mode'] =
          Variable<String>(pointsRenderingMode.value);
    }
    if (minutesBetweenRoutes.present) {
      map['minutes_between_routes'] = Variable<int>(minutesBetweenRoutes.value);
    }
    if (timeThresholdMinutes.present) {
      map['time_threshold_minutes'] = Variable<int>(timeThresholdMinutes.value);
    }
    if (mergeThresholdMinutes.present) {
      map['merge_threshold_minutes'] =
          Variable<int>(mergeThresholdMinutes.value);
    }
    if (liveMapEnabled.present) {
      map['live_map_enabled'] = Variable<bool>(liveMapEnabled.value);
    }
    if (routeOpacity.present) {
      map['route_opacity'] = Variable<double>(routeOpacity.value);
    }
    if (visitsSuggestionsEnabled.present) {
      map['visits_suggestions_enabled'] =
          Variable<bool>(visitsSuggestionsEnabled.value);
    }
    if (speedColorScale.present) {
      map['speed_color_scale'] = Variable<String>(speedColorScale.value);
    }
    if (fogOfWarThreshold.present) {
      map['fog_of_war_threshold'] = Variable<int>(fogOfWarThreshold.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserSettingsTableCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('immichUrl: $immichUrl, ')
          ..write('immichApiKey: $immichApiKey, ')
          ..write('photoprismUrl: $photoprismUrl, ')
          ..write('photoprismApiKey: $photoprismApiKey, ')
          ..write('distanceUnit: $distanceUnit, ')
          ..write('fogOfWarMeters: $fogOfWarMeters, ')
          ..write('metersBetweenRoutes: $metersBetweenRoutes, ')
          ..write('preferredMapLayer: $preferredMapLayer, ')
          ..write('speedColoredRoutes: $speedColoredRoutes, ')
          ..write('pointsRenderingMode: $pointsRenderingMode, ')
          ..write('minutesBetweenRoutes: $minutesBetweenRoutes, ')
          ..write('timeThresholdMinutes: $timeThresholdMinutes, ')
          ..write('mergeThresholdMinutes: $mergeThresholdMinutes, ')
          ..write('liveMapEnabled: $liveMapEnabled, ')
          ..write('routeOpacity: $routeOpacity, ')
          ..write('visitsSuggestionsEnabled: $visitsSuggestionsEnabled, ')
          ..write('speedColorScale: $speedColorScale, ')
          ..write('fogOfWarThreshold: $fogOfWarThreshold')
          ..write(')'))
        .toString();
  }
}

class PointGeometryTable extends Table
    with TableInfo<PointGeometryTable, PointGeometryTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  PointGeometryTable(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
      'longitude', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const CustomExpression('0.0'));
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
      'latitude', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const CustomExpression('0.0'));
  @override
  List<GeneratedColumn> get $columns => [id, type, longitude, latitude];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'point_geometry_table';
  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PointGeometryTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PointGeometryTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type'])!,
      longitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}longitude'])!,
      latitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}latitude'])!,
    );
  }

  @override
  PointGeometryTable createAlias(String alias) {
    return PointGeometryTable(attachedDatabase, alias);
  }
}

class PointGeometryTableData extends DataClass
    implements Insertable<PointGeometryTableData> {
  final int id;
  final String type;
  final double longitude;
  final double latitude;
  const PointGeometryTableData(
      {required this.id,
      required this.type,
      required this.longitude,
      required this.latitude});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['type'] = Variable<String>(type);
    map['longitude'] = Variable<double>(longitude);
    map['latitude'] = Variable<double>(latitude);
    return map;
  }

  PointGeometryTableCompanion toCompanion(bool nullToAbsent) {
    return PointGeometryTableCompanion(
      id: Value(id),
      type: Value(type),
      longitude: Value(longitude),
      latitude: Value(latitude),
    );
  }

  factory PointGeometryTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PointGeometryTableData(
      id: serializer.fromJson<int>(json['id']),
      type: serializer.fromJson<String>(json['type']),
      longitude: serializer.fromJson<double>(json['longitude']),
      latitude: serializer.fromJson<double>(json['latitude']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'type': serializer.toJson<String>(type),
      'longitude': serializer.toJson<double>(longitude),
      'latitude': serializer.toJson<double>(latitude),
    };
  }

  PointGeometryTableData copyWith(
          {int? id, String? type, double? longitude, double? latitude}) =>
      PointGeometryTableData(
        id: id ?? this.id,
        type: type ?? this.type,
        longitude: longitude ?? this.longitude,
        latitude: latitude ?? this.latitude,
      );
  PointGeometryTableData copyWithCompanion(PointGeometryTableCompanion data) {
    return PointGeometryTableData(
      id: data.id.present ? data.id.value : this.id,
      type: data.type.present ? data.type.value : this.type,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PointGeometryTableData(')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('longitude: $longitude, ')
          ..write('latitude: $latitude')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, type, longitude, latitude);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PointGeometryTableData &&
          other.id == this.id &&
          other.type == this.type &&
          other.longitude == this.longitude &&
          other.latitude == this.latitude);
}

class PointGeometryTableCompanion
    extends UpdateCompanion<PointGeometryTableData> {
  final Value<int> id;
  final Value<String> type;
  final Value<double> longitude;
  final Value<double> latitude;
  const PointGeometryTableCompanion({
    this.id = const Value.absent(),
    this.type = const Value.absent(),
    this.longitude = const Value.absent(),
    this.latitude = const Value.absent(),
  });
  PointGeometryTableCompanion.insert({
    this.id = const Value.absent(),
    required String type,
    this.longitude = const Value.absent(),
    this.latitude = const Value.absent(),
  }) : type = Value(type);
  static Insertable<PointGeometryTableData> custom({
    Expression<int>? id,
    Expression<String>? type,
    Expression<double>? longitude,
    Expression<double>? latitude,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (type != null) 'type': type,
      if (longitude != null) 'longitude': longitude,
      if (latitude != null) 'latitude': latitude,
    });
  }

  PointGeometryTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? type,
      Value<double>? longitude,
      Value<double>? latitude}) {
    return PointGeometryTableCompanion(
      id: id ?? this.id,
      type: type ?? this.type,
      longitude: longitude ?? this.longitude,
      latitude: latitude ?? this.latitude,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PointGeometryTableCompanion(')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('longitude: $longitude, ')
          ..write('latitude: $latitude')
          ..write(')'))
        .toString();
  }
}

class PointPropertiesTable extends Table
    with TableInfo<PointPropertiesTable, PointPropertiesTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  PointPropertiesTable(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  late final GeneratedColumn<String> batteryState = GeneratedColumn<String>(
      'battery_state', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  late final GeneratedColumn<double> batteryLevel = GeneratedColumn<double>(
      'battery_level', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  late final GeneratedColumn<String> wifi = GeneratedColumn<String>(
      'wifi', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  late final GeneratedColumn<DateTime> recordTimestamp =
      GeneratedColumn<DateTime>('record_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime, requiredDuringInsert: true);
  late final GeneratedColumn<DateTime> providerTimestamp =
      GeneratedColumn<DateTime>('provider_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime, requiredDuringInsert: true);
  late final GeneratedColumn<double> altitude = GeneratedColumn<double>(
      'altitude', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  late final GeneratedColumn<double> speed = GeneratedColumn<double>(
      'speed', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  late final GeneratedColumn<double> horizontalAccuracy =
      GeneratedColumn<double>('horizontal_accuracy', aliasedName, false,
          type: DriftSqlType.double, requiredDuringInsert: true);
  late final GeneratedColumn<double> verticalAccuracy = GeneratedColumn<double>(
      'vertical_accuracy', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  late final GeneratedColumn<double> speedAccuracy = GeneratedColumn<double>(
      'speed_accuracy', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  late final GeneratedColumn<double> course = GeneratedColumn<double>(
      'course', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  late final GeneratedColumn<double> courseAccuracy = GeneratedColumn<double>(
      'course_accuracy', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  late final GeneratedColumn<String> trackId = GeneratedColumn<String>(
      'track_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  late final GeneratedColumn<String> deviceId = GeneratedColumn<String>(
      'device_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        batteryState,
        batteryLevel,
        wifi,
        recordTimestamp,
        providerTimestamp,
        altitude,
        speed,
        horizontalAccuracy,
        verticalAccuracy,
        speedAccuracy,
        course,
        courseAccuracy,
        trackId,
        deviceId
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'point_properties_table';
  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PointPropertiesTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PointPropertiesTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      batteryState: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}battery_state'])!,
      batteryLevel: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}battery_level'])!,
      wifi: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}wifi'])!,
      recordTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}record_timestamp'])!,
      providerTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}provider_timestamp'])!,
      altitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}altitude'])!,
      speed: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}speed'])!,
      horizontalAccuracy: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}horizontal_accuracy'])!,
      verticalAccuracy: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}vertical_accuracy'])!,
      speedAccuracy: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}speed_accuracy'])!,
      course: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}course'])!,
      courseAccuracy: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}course_accuracy'])!,
      trackId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}track_id']),
      deviceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_id'])!,
    );
  }

  @override
  PointPropertiesTable createAlias(String alias) {
    return PointPropertiesTable(attachedDatabase, alias);
  }
}

class PointPropertiesTableData extends DataClass
    implements Insertable<PointPropertiesTableData> {
  final int id;
  final String batteryState;
  final double batteryLevel;
  final String wifi;
  final DateTime recordTimestamp;
  final DateTime providerTimestamp;
  final double altitude;
  final double speed;
  final double horizontalAccuracy;
  final double verticalAccuracy;
  final double speedAccuracy;
  final double course;
  final double courseAccuracy;
  final String? trackId;
  final String deviceId;
  const PointPropertiesTableData(
      {required this.id,
      required this.batteryState,
      required this.batteryLevel,
      required this.wifi,
      required this.recordTimestamp,
      required this.providerTimestamp,
      required this.altitude,
      required this.speed,
      required this.horizontalAccuracy,
      required this.verticalAccuracy,
      required this.speedAccuracy,
      required this.course,
      required this.courseAccuracy,
      this.trackId,
      required this.deviceId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['battery_state'] = Variable<String>(batteryState);
    map['battery_level'] = Variable<double>(batteryLevel);
    map['wifi'] = Variable<String>(wifi);
    map['record_timestamp'] = Variable<DateTime>(recordTimestamp);
    map['provider_timestamp'] = Variable<DateTime>(providerTimestamp);
    map['altitude'] = Variable<double>(altitude);
    map['speed'] = Variable<double>(speed);
    map['horizontal_accuracy'] = Variable<double>(horizontalAccuracy);
    map['vertical_accuracy'] = Variable<double>(verticalAccuracy);
    map['speed_accuracy'] = Variable<double>(speedAccuracy);
    map['course'] = Variable<double>(course);
    map['course_accuracy'] = Variable<double>(courseAccuracy);
    if (!nullToAbsent || trackId != null) {
      map['track_id'] = Variable<String>(trackId);
    }
    map['device_id'] = Variable<String>(deviceId);
    return map;
  }

  PointPropertiesTableCompanion toCompanion(bool nullToAbsent) {
    return PointPropertiesTableCompanion(
      id: Value(id),
      batteryState: Value(batteryState),
      batteryLevel: Value(batteryLevel),
      wifi: Value(wifi),
      recordTimestamp: Value(recordTimestamp),
      providerTimestamp: Value(providerTimestamp),
      altitude: Value(altitude),
      speed: Value(speed),
      horizontalAccuracy: Value(horizontalAccuracy),
      verticalAccuracy: Value(verticalAccuracy),
      speedAccuracy: Value(speedAccuracy),
      course: Value(course),
      courseAccuracy: Value(courseAccuracy),
      trackId: trackId == null && nullToAbsent
          ? const Value.absent()
          : Value(trackId),
      deviceId: Value(deviceId),
    );
  }

  factory PointPropertiesTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PointPropertiesTableData(
      id: serializer.fromJson<int>(json['id']),
      batteryState: serializer.fromJson<String>(json['batteryState']),
      batteryLevel: serializer.fromJson<double>(json['batteryLevel']),
      wifi: serializer.fromJson<String>(json['wifi']),
      recordTimestamp: serializer.fromJson<DateTime>(json['recordTimestamp']),
      providerTimestamp:
          serializer.fromJson<DateTime>(json['providerTimestamp']),
      altitude: serializer.fromJson<double>(json['altitude']),
      speed: serializer.fromJson<double>(json['speed']),
      horizontalAccuracy:
          serializer.fromJson<double>(json['horizontalAccuracy']),
      verticalAccuracy: serializer.fromJson<double>(json['verticalAccuracy']),
      speedAccuracy: serializer.fromJson<double>(json['speedAccuracy']),
      course: serializer.fromJson<double>(json['course']),
      courseAccuracy: serializer.fromJson<double>(json['courseAccuracy']),
      trackId: serializer.fromJson<String?>(json['trackId']),
      deviceId: serializer.fromJson<String>(json['deviceId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'batteryState': serializer.toJson<String>(batteryState),
      'batteryLevel': serializer.toJson<double>(batteryLevel),
      'wifi': serializer.toJson<String>(wifi),
      'recordTimestamp': serializer.toJson<DateTime>(recordTimestamp),
      'providerTimestamp': serializer.toJson<DateTime>(providerTimestamp),
      'altitude': serializer.toJson<double>(altitude),
      'speed': serializer.toJson<double>(speed),
      'horizontalAccuracy': serializer.toJson<double>(horizontalAccuracy),
      'verticalAccuracy': serializer.toJson<double>(verticalAccuracy),
      'speedAccuracy': serializer.toJson<double>(speedAccuracy),
      'course': serializer.toJson<double>(course),
      'courseAccuracy': serializer.toJson<double>(courseAccuracy),
      'trackId': serializer.toJson<String?>(trackId),
      'deviceId': serializer.toJson<String>(deviceId),
    };
  }

  PointPropertiesTableData copyWith(
          {int? id,
          String? batteryState,
          double? batteryLevel,
          String? wifi,
          DateTime? recordTimestamp,
          DateTime? providerTimestamp,
          double? altitude,
          double? speed,
          double? horizontalAccuracy,
          double? verticalAccuracy,
          double? speedAccuracy,
          double? course,
          double? courseAccuracy,
          Value<String?> trackId = const Value.absent(),
          String? deviceId}) =>
      PointPropertiesTableData(
        id: id ?? this.id,
        batteryState: batteryState ?? this.batteryState,
        batteryLevel: batteryLevel ?? this.batteryLevel,
        wifi: wifi ?? this.wifi,
        recordTimestamp: recordTimestamp ?? this.recordTimestamp,
        providerTimestamp: providerTimestamp ?? this.providerTimestamp,
        altitude: altitude ?? this.altitude,
        speed: speed ?? this.speed,
        horizontalAccuracy: horizontalAccuracy ?? this.horizontalAccuracy,
        verticalAccuracy: verticalAccuracy ?? this.verticalAccuracy,
        speedAccuracy: speedAccuracy ?? this.speedAccuracy,
        course: course ?? this.course,
        courseAccuracy: courseAccuracy ?? this.courseAccuracy,
        trackId: trackId.present ? trackId.value : this.trackId,
        deviceId: deviceId ?? this.deviceId,
      );
  PointPropertiesTableData copyWithCompanion(
      PointPropertiesTableCompanion data) {
    return PointPropertiesTableData(
      id: data.id.present ? data.id.value : this.id,
      batteryState: data.batteryState.present
          ? data.batteryState.value
          : this.batteryState,
      batteryLevel: data.batteryLevel.present
          ? data.batteryLevel.value
          : this.batteryLevel,
      wifi: data.wifi.present ? data.wifi.value : this.wifi,
      recordTimestamp: data.recordTimestamp.present
          ? data.recordTimestamp.value
          : this.recordTimestamp,
      providerTimestamp: data.providerTimestamp.present
          ? data.providerTimestamp.value
          : this.providerTimestamp,
      altitude: data.altitude.present ? data.altitude.value : this.altitude,
      speed: data.speed.present ? data.speed.value : this.speed,
      horizontalAccuracy: data.horizontalAccuracy.present
          ? data.horizontalAccuracy.value
          : this.horizontalAccuracy,
      verticalAccuracy: data.verticalAccuracy.present
          ? data.verticalAccuracy.value
          : this.verticalAccuracy,
      speedAccuracy: data.speedAccuracy.present
          ? data.speedAccuracy.value
          : this.speedAccuracy,
      course: data.course.present ? data.course.value : this.course,
      courseAccuracy: data.courseAccuracy.present
          ? data.courseAccuracy.value
          : this.courseAccuracy,
      trackId: data.trackId.present ? data.trackId.value : this.trackId,
      deviceId: data.deviceId.present ? data.deviceId.value : this.deviceId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PointPropertiesTableData(')
          ..write('id: $id, ')
          ..write('batteryState: $batteryState, ')
          ..write('batteryLevel: $batteryLevel, ')
          ..write('wifi: $wifi, ')
          ..write('recordTimestamp: $recordTimestamp, ')
          ..write('providerTimestamp: $providerTimestamp, ')
          ..write('altitude: $altitude, ')
          ..write('speed: $speed, ')
          ..write('horizontalAccuracy: $horizontalAccuracy, ')
          ..write('verticalAccuracy: $verticalAccuracy, ')
          ..write('speedAccuracy: $speedAccuracy, ')
          ..write('course: $course, ')
          ..write('courseAccuracy: $courseAccuracy, ')
          ..write('trackId: $trackId, ')
          ..write('deviceId: $deviceId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      batteryState,
      batteryLevel,
      wifi,
      recordTimestamp,
      providerTimestamp,
      altitude,
      speed,
      horizontalAccuracy,
      verticalAccuracy,
      speedAccuracy,
      course,
      courseAccuracy,
      trackId,
      deviceId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PointPropertiesTableData &&
          other.id == this.id &&
          other.batteryState == this.batteryState &&
          other.batteryLevel == this.batteryLevel &&
          other.wifi == this.wifi &&
          other.recordTimestamp == this.recordTimestamp &&
          other.providerTimestamp == this.providerTimestamp &&
          other.altitude == this.altitude &&
          other.speed == this.speed &&
          other.horizontalAccuracy == this.horizontalAccuracy &&
          other.verticalAccuracy == this.verticalAccuracy &&
          other.speedAccuracy == this.speedAccuracy &&
          other.course == this.course &&
          other.courseAccuracy == this.courseAccuracy &&
          other.trackId == this.trackId &&
          other.deviceId == this.deviceId);
}

class PointPropertiesTableCompanion
    extends UpdateCompanion<PointPropertiesTableData> {
  final Value<int> id;
  final Value<String> batteryState;
  final Value<double> batteryLevel;
  final Value<String> wifi;
  final Value<DateTime> recordTimestamp;
  final Value<DateTime> providerTimestamp;
  final Value<double> altitude;
  final Value<double> speed;
  final Value<double> horizontalAccuracy;
  final Value<double> verticalAccuracy;
  final Value<double> speedAccuracy;
  final Value<double> course;
  final Value<double> courseAccuracy;
  final Value<String?> trackId;
  final Value<String> deviceId;
  const PointPropertiesTableCompanion({
    this.id = const Value.absent(),
    this.batteryState = const Value.absent(),
    this.batteryLevel = const Value.absent(),
    this.wifi = const Value.absent(),
    this.recordTimestamp = const Value.absent(),
    this.providerTimestamp = const Value.absent(),
    this.altitude = const Value.absent(),
    this.speed = const Value.absent(),
    this.horizontalAccuracy = const Value.absent(),
    this.verticalAccuracy = const Value.absent(),
    this.speedAccuracy = const Value.absent(),
    this.course = const Value.absent(),
    this.courseAccuracy = const Value.absent(),
    this.trackId = const Value.absent(),
    this.deviceId = const Value.absent(),
  });
  PointPropertiesTableCompanion.insert({
    this.id = const Value.absent(),
    required String batteryState,
    required double batteryLevel,
    required String wifi,
    required DateTime recordTimestamp,
    required DateTime providerTimestamp,
    required double altitude,
    required double speed,
    required double horizontalAccuracy,
    required double verticalAccuracy,
    required double speedAccuracy,
    required double course,
    required double courseAccuracy,
    this.trackId = const Value.absent(),
    required String deviceId,
  })  : batteryState = Value(batteryState),
        batteryLevel = Value(batteryLevel),
        wifi = Value(wifi),
        recordTimestamp = Value(recordTimestamp),
        providerTimestamp = Value(providerTimestamp),
        altitude = Value(altitude),
        speed = Value(speed),
        horizontalAccuracy = Value(horizontalAccuracy),
        verticalAccuracy = Value(verticalAccuracy),
        speedAccuracy = Value(speedAccuracy),
        course = Value(course),
        courseAccuracy = Value(courseAccuracy),
        deviceId = Value(deviceId);
  static Insertable<PointPropertiesTableData> custom({
    Expression<int>? id,
    Expression<String>? batteryState,
    Expression<double>? batteryLevel,
    Expression<String>? wifi,
    Expression<DateTime>? recordTimestamp,
    Expression<DateTime>? providerTimestamp,
    Expression<double>? altitude,
    Expression<double>? speed,
    Expression<double>? horizontalAccuracy,
    Expression<double>? verticalAccuracy,
    Expression<double>? speedAccuracy,
    Expression<double>? course,
    Expression<double>? courseAccuracy,
    Expression<String>? trackId,
    Expression<String>? deviceId,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (batteryState != null) 'battery_state': batteryState,
      if (batteryLevel != null) 'battery_level': batteryLevel,
      if (wifi != null) 'wifi': wifi,
      if (recordTimestamp != null) 'record_timestamp': recordTimestamp,
      if (providerTimestamp != null) 'provider_timestamp': providerTimestamp,
      if (altitude != null) 'altitude': altitude,
      if (speed != null) 'speed': speed,
      if (horizontalAccuracy != null) 'horizontal_accuracy': horizontalAccuracy,
      if (verticalAccuracy != null) 'vertical_accuracy': verticalAccuracy,
      if (speedAccuracy != null) 'speed_accuracy': speedAccuracy,
      if (course != null) 'course': course,
      if (courseAccuracy != null) 'course_accuracy': courseAccuracy,
      if (trackId != null) 'track_id': trackId,
      if (deviceId != null) 'device_id': deviceId,
    });
  }

  PointPropertiesTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? batteryState,
      Value<double>? batteryLevel,
      Value<String>? wifi,
      Value<DateTime>? recordTimestamp,
      Value<DateTime>? providerTimestamp,
      Value<double>? altitude,
      Value<double>? speed,
      Value<double>? horizontalAccuracy,
      Value<double>? verticalAccuracy,
      Value<double>? speedAccuracy,
      Value<double>? course,
      Value<double>? courseAccuracy,
      Value<String?>? trackId,
      Value<String>? deviceId}) {
    return PointPropertiesTableCompanion(
      id: id ?? this.id,
      batteryState: batteryState ?? this.batteryState,
      batteryLevel: batteryLevel ?? this.batteryLevel,
      wifi: wifi ?? this.wifi,
      recordTimestamp: recordTimestamp ?? this.recordTimestamp,
      providerTimestamp: providerTimestamp ?? this.providerTimestamp,
      altitude: altitude ?? this.altitude,
      speed: speed ?? this.speed,
      horizontalAccuracy: horizontalAccuracy ?? this.horizontalAccuracy,
      verticalAccuracy: verticalAccuracy ?? this.verticalAccuracy,
      speedAccuracy: speedAccuracy ?? this.speedAccuracy,
      course: course ?? this.course,
      courseAccuracy: courseAccuracy ?? this.courseAccuracy,
      trackId: trackId ?? this.trackId,
      deviceId: deviceId ?? this.deviceId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (batteryState.present) {
      map['battery_state'] = Variable<String>(batteryState.value);
    }
    if (batteryLevel.present) {
      map['battery_level'] = Variable<double>(batteryLevel.value);
    }
    if (wifi.present) {
      map['wifi'] = Variable<String>(wifi.value);
    }
    if (recordTimestamp.present) {
      map['record_timestamp'] = Variable<DateTime>(recordTimestamp.value);
    }
    if (providerTimestamp.present) {
      map['provider_timestamp'] = Variable<DateTime>(providerTimestamp.value);
    }
    if (altitude.present) {
      map['altitude'] = Variable<double>(altitude.value);
    }
    if (speed.present) {
      map['speed'] = Variable<double>(speed.value);
    }
    if (horizontalAccuracy.present) {
      map['horizontal_accuracy'] = Variable<double>(horizontalAccuracy.value);
    }
    if (verticalAccuracy.present) {
      map['vertical_accuracy'] = Variable<double>(verticalAccuracy.value);
    }
    if (speedAccuracy.present) {
      map['speed_accuracy'] = Variable<double>(speedAccuracy.value);
    }
    if (course.present) {
      map['course'] = Variable<double>(course.value);
    }
    if (courseAccuracy.present) {
      map['course_accuracy'] = Variable<double>(courseAccuracy.value);
    }
    if (trackId.present) {
      map['track_id'] = Variable<String>(trackId.value);
    }
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PointPropertiesTableCompanion(')
          ..write('id: $id, ')
          ..write('batteryState: $batteryState, ')
          ..write('batteryLevel: $batteryLevel, ')
          ..write('wifi: $wifi, ')
          ..write('recordTimestamp: $recordTimestamp, ')
          ..write('providerTimestamp: $providerTimestamp, ')
          ..write('altitude: $altitude, ')
          ..write('speed: $speed, ')
          ..write('horizontalAccuracy: $horizontalAccuracy, ')
          ..write('verticalAccuracy: $verticalAccuracy, ')
          ..write('speedAccuracy: $speedAccuracy, ')
          ..write('course: $course, ')
          ..write('courseAccuracy: $courseAccuracy, ')
          ..write('trackId: $trackId, ')
          ..write('deviceId: $deviceId')
          ..write(')'))
        .toString();
  }
}

class PointsTable extends Table with TableInfo<PointsTable, PointsTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  PointsTable(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  late final GeneratedColumn<int> geometryId = GeneratedColumn<int>(
      'geometry_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES point_geometry_table (id)'));
  late final GeneratedColumn<int> propertiesId = GeneratedColumn<int>(
      'properties_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES point_properties_table (id)'));
  late final GeneratedColumn<String> deduplicationKey = GeneratedColumn<String>(
      'deduplication_key', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  late final GeneratedColumn<int> userId = GeneratedColumn<int>(
      'user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  late final GeneratedColumn<bool> isUploaded = GeneratedColumn<bool>(
      'is_uploaded', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_uploaded" IN (0, 1))'),
      defaultValue: const CustomExpression('0'));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        type,
        geometryId,
        propertiesId,
        deduplicationKey,
        userId,
        isUploaded
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'points_table';
  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {deduplicationKey},
      ];
  @override
  PointsTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PointsTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type'])!,
      geometryId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}geometry_id'])!,
      propertiesId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}properties_id'])!,
      deduplicationKey: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}deduplication_key']),
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}user_id'])!,
      isUploaded: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_uploaded'])!,
    );
  }

  @override
  PointsTable createAlias(String alias) {
    return PointsTable(attachedDatabase, alias);
  }
}

class PointsTableData extends DataClass implements Insertable<PointsTableData> {
  final int id;
  final String type;
  final int geometryId;
  final int propertiesId;
  final String? deduplicationKey;
  final int userId;
  final bool isUploaded;
  const PointsTableData(
      {required this.id,
      required this.type,
      required this.geometryId,
      required this.propertiesId,
      this.deduplicationKey,
      required this.userId,
      required this.isUploaded});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['type'] = Variable<String>(type);
    map['geometry_id'] = Variable<int>(geometryId);
    map['properties_id'] = Variable<int>(propertiesId);
    if (!nullToAbsent || deduplicationKey != null) {
      map['deduplication_key'] = Variable<String>(deduplicationKey);
    }
    map['user_id'] = Variable<int>(userId);
    map['is_uploaded'] = Variable<bool>(isUploaded);
    return map;
  }

  PointsTableCompanion toCompanion(bool nullToAbsent) {
    return PointsTableCompanion(
      id: Value(id),
      type: Value(type),
      geometryId: Value(geometryId),
      propertiesId: Value(propertiesId),
      deduplicationKey: deduplicationKey == null && nullToAbsent
          ? const Value.absent()
          : Value(deduplicationKey),
      userId: Value(userId),
      isUploaded: Value(isUploaded),
    );
  }

  factory PointsTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PointsTableData(
      id: serializer.fromJson<int>(json['id']),
      type: serializer.fromJson<String>(json['type']),
      geometryId: serializer.fromJson<int>(json['geometryId']),
      propertiesId: serializer.fromJson<int>(json['propertiesId']),
      deduplicationKey: serializer.fromJson<String?>(json['deduplicationKey']),
      userId: serializer.fromJson<int>(json['userId']),
      isUploaded: serializer.fromJson<bool>(json['isUploaded']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'type': serializer.toJson<String>(type),
      'geometryId': serializer.toJson<int>(geometryId),
      'propertiesId': serializer.toJson<int>(propertiesId),
      'deduplicationKey': serializer.toJson<String?>(deduplicationKey),
      'userId': serializer.toJson<int>(userId),
      'isUploaded': serializer.toJson<bool>(isUploaded),
    };
  }

  PointsTableData copyWith(
          {int? id,
          String? type,
          int? geometryId,
          int? propertiesId,
          Value<String?> deduplicationKey = const Value.absent(),
          int? userId,
          bool? isUploaded}) =>
      PointsTableData(
        id: id ?? this.id,
        type: type ?? this.type,
        geometryId: geometryId ?? this.geometryId,
        propertiesId: propertiesId ?? this.propertiesId,
        deduplicationKey: deduplicationKey.present
            ? deduplicationKey.value
            : this.deduplicationKey,
        userId: userId ?? this.userId,
        isUploaded: isUploaded ?? this.isUploaded,
      );
  PointsTableData copyWithCompanion(PointsTableCompanion data) {
    return PointsTableData(
      id: data.id.present ? data.id.value : this.id,
      type: data.type.present ? data.type.value : this.type,
      geometryId:
          data.geometryId.present ? data.geometryId.value : this.geometryId,
      propertiesId: data.propertiesId.present
          ? data.propertiesId.value
          : this.propertiesId,
      deduplicationKey: data.deduplicationKey.present
          ? data.deduplicationKey.value
          : this.deduplicationKey,
      userId: data.userId.present ? data.userId.value : this.userId,
      isUploaded:
          data.isUploaded.present ? data.isUploaded.value : this.isUploaded,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PointsTableData(')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('geometryId: $geometryId, ')
          ..write('propertiesId: $propertiesId, ')
          ..write('deduplicationKey: $deduplicationKey, ')
          ..write('userId: $userId, ')
          ..write('isUploaded: $isUploaded')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, type, geometryId, propertiesId, deduplicationKey, userId, isUploaded);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PointsTableData &&
          other.id == this.id &&
          other.type == this.type &&
          other.geometryId == this.geometryId &&
          other.propertiesId == this.propertiesId &&
          other.deduplicationKey == this.deduplicationKey &&
          other.userId == this.userId &&
          other.isUploaded == this.isUploaded);
}

class PointsTableCompanion extends UpdateCompanion<PointsTableData> {
  final Value<int> id;
  final Value<String> type;
  final Value<int> geometryId;
  final Value<int> propertiesId;
  final Value<String?> deduplicationKey;
  final Value<int> userId;
  final Value<bool> isUploaded;
  const PointsTableCompanion({
    this.id = const Value.absent(),
    this.type = const Value.absent(),
    this.geometryId = const Value.absent(),
    this.propertiesId = const Value.absent(),
    this.deduplicationKey = const Value.absent(),
    this.userId = const Value.absent(),
    this.isUploaded = const Value.absent(),
  });
  PointsTableCompanion.insert({
    this.id = const Value.absent(),
    required String type,
    required int geometryId,
    required int propertiesId,
    this.deduplicationKey = const Value.absent(),
    required int userId,
    this.isUploaded = const Value.absent(),
  })  : type = Value(type),
        geometryId = Value(geometryId),
        propertiesId = Value(propertiesId),
        userId = Value(userId);
  static Insertable<PointsTableData> custom({
    Expression<int>? id,
    Expression<String>? type,
    Expression<int>? geometryId,
    Expression<int>? propertiesId,
    Expression<String>? deduplicationKey,
    Expression<int>? userId,
    Expression<bool>? isUploaded,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (type != null) 'type': type,
      if (geometryId != null) 'geometry_id': geometryId,
      if (propertiesId != null) 'properties_id': propertiesId,
      if (deduplicationKey != null) 'deduplication_key': deduplicationKey,
      if (userId != null) 'user_id': userId,
      if (isUploaded != null) 'is_uploaded': isUploaded,
    });
  }

  PointsTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? type,
      Value<int>? geometryId,
      Value<int>? propertiesId,
      Value<String?>? deduplicationKey,
      Value<int>? userId,
      Value<bool>? isUploaded}) {
    return PointsTableCompanion(
      id: id ?? this.id,
      type: type ?? this.type,
      geometryId: geometryId ?? this.geometryId,
      propertiesId: propertiesId ?? this.propertiesId,
      deduplicationKey: deduplicationKey ?? this.deduplicationKey,
      userId: userId ?? this.userId,
      isUploaded: isUploaded ?? this.isUploaded,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (geometryId.present) {
      map['geometry_id'] = Variable<int>(geometryId.value);
    }
    if (propertiesId.present) {
      map['properties_id'] = Variable<int>(propertiesId.value);
    }
    if (deduplicationKey.present) {
      map['deduplication_key'] = Variable<String>(deduplicationKey.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    if (isUploaded.present) {
      map['is_uploaded'] = Variable<bool>(isUploaded.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PointsTableCompanion(')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('geometryId: $geometryId, ')
          ..write('propertiesId: $propertiesId, ')
          ..write('deduplicationKey: $deduplicationKey, ')
          ..write('userId: $userId, ')
          ..write('isUploaded: $isUploaded')
          ..write(')'))
        .toString();
  }
}

class TrackTable extends Table with TableInfo<TrackTable, TrackTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  TrackTable(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  late final GeneratedColumn<String> trackId = GeneratedColumn<String>(
      'track_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  late final GeneratedColumn<DateTime> startTimestamp =
      GeneratedColumn<DateTime>('start_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime, requiredDuringInsert: true);
  late final GeneratedColumn<DateTime> endTimestamp = GeneratedColumn<DateTime>(
      'end_timestamp', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  late final GeneratedColumn<bool> active = GeneratedColumn<bool>(
      'active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("active" IN (0, 1))'),
      defaultValue: const CustomExpression('1'));
  late final GeneratedColumn<int> userId = GeneratedColumn<int>(
      'user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [id, trackId, startTimestamp, endTimestamp, active, userId];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'track_table';
  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  TrackTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TrackTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      trackId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}track_id'])!,
      startTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}start_timestamp'])!,
      endTimestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}end_timestamp']),
      active: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}active'])!,
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}user_id'])!,
    );
  }

  @override
  TrackTable createAlias(String alias) {
    return TrackTable(attachedDatabase, alias);
  }
}

class TrackTableData extends DataClass implements Insertable<TrackTableData> {
  final int id;
  final String trackId;
  final DateTime startTimestamp;
  final DateTime? endTimestamp;
  final bool active;
  final int userId;
  const TrackTableData(
      {required this.id,
      required this.trackId,
      required this.startTimestamp,
      this.endTimestamp,
      required this.active,
      required this.userId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['track_id'] = Variable<String>(trackId);
    map['start_timestamp'] = Variable<DateTime>(startTimestamp);
    if (!nullToAbsent || endTimestamp != null) {
      map['end_timestamp'] = Variable<DateTime>(endTimestamp);
    }
    map['active'] = Variable<bool>(active);
    map['user_id'] = Variable<int>(userId);
    return map;
  }

  TrackTableCompanion toCompanion(bool nullToAbsent) {
    return TrackTableCompanion(
      id: Value(id),
      trackId: Value(trackId),
      startTimestamp: Value(startTimestamp),
      endTimestamp: endTimestamp == null && nullToAbsent
          ? const Value.absent()
          : Value(endTimestamp),
      active: Value(active),
      userId: Value(userId),
    );
  }

  factory TrackTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TrackTableData(
      id: serializer.fromJson<int>(json['id']),
      trackId: serializer.fromJson<String>(json['trackId']),
      startTimestamp: serializer.fromJson<DateTime>(json['startTimestamp']),
      endTimestamp: serializer.fromJson<DateTime?>(json['endTimestamp']),
      active: serializer.fromJson<bool>(json['active']),
      userId: serializer.fromJson<int>(json['userId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'trackId': serializer.toJson<String>(trackId),
      'startTimestamp': serializer.toJson<DateTime>(startTimestamp),
      'endTimestamp': serializer.toJson<DateTime?>(endTimestamp),
      'active': serializer.toJson<bool>(active),
      'userId': serializer.toJson<int>(userId),
    };
  }

  TrackTableData copyWith(
          {int? id,
          String? trackId,
          DateTime? startTimestamp,
          Value<DateTime?> endTimestamp = const Value.absent(),
          bool? active,
          int? userId}) =>
      TrackTableData(
        id: id ?? this.id,
        trackId: trackId ?? this.trackId,
        startTimestamp: startTimestamp ?? this.startTimestamp,
        endTimestamp:
            endTimestamp.present ? endTimestamp.value : this.endTimestamp,
        active: active ?? this.active,
        userId: userId ?? this.userId,
      );
  TrackTableData copyWithCompanion(TrackTableCompanion data) {
    return TrackTableData(
      id: data.id.present ? data.id.value : this.id,
      trackId: data.trackId.present ? data.trackId.value : this.trackId,
      startTimestamp: data.startTimestamp.present
          ? data.startTimestamp.value
          : this.startTimestamp,
      endTimestamp: data.endTimestamp.present
          ? data.endTimestamp.value
          : this.endTimestamp,
      active: data.active.present ? data.active.value : this.active,
      userId: data.userId.present ? data.userId.value : this.userId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TrackTableData(')
          ..write('id: $id, ')
          ..write('trackId: $trackId, ')
          ..write('startTimestamp: $startTimestamp, ')
          ..write('endTimestamp: $endTimestamp, ')
          ..write('active: $active, ')
          ..write('userId: $userId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, trackId, startTimestamp, endTimestamp, active, userId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TrackTableData &&
          other.id == this.id &&
          other.trackId == this.trackId &&
          other.startTimestamp == this.startTimestamp &&
          other.endTimestamp == this.endTimestamp &&
          other.active == this.active &&
          other.userId == this.userId);
}

class TrackTableCompanion extends UpdateCompanion<TrackTableData> {
  final Value<int> id;
  final Value<String> trackId;
  final Value<DateTime> startTimestamp;
  final Value<DateTime?> endTimestamp;
  final Value<bool> active;
  final Value<int> userId;
  const TrackTableCompanion({
    this.id = const Value.absent(),
    this.trackId = const Value.absent(),
    this.startTimestamp = const Value.absent(),
    this.endTimestamp = const Value.absent(),
    this.active = const Value.absent(),
    this.userId = const Value.absent(),
  });
  TrackTableCompanion.insert({
    this.id = const Value.absent(),
    required String trackId,
    required DateTime startTimestamp,
    this.endTimestamp = const Value.absent(),
    this.active = const Value.absent(),
    required int userId,
  })  : trackId = Value(trackId),
        startTimestamp = Value(startTimestamp),
        userId = Value(userId);
  static Insertable<TrackTableData> custom({
    Expression<int>? id,
    Expression<String>? trackId,
    Expression<DateTime>? startTimestamp,
    Expression<DateTime>? endTimestamp,
    Expression<bool>? active,
    Expression<int>? userId,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (trackId != null) 'track_id': trackId,
      if (startTimestamp != null) 'start_timestamp': startTimestamp,
      if (endTimestamp != null) 'end_timestamp': endTimestamp,
      if (active != null) 'active': active,
      if (userId != null) 'user_id': userId,
    });
  }

  TrackTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? trackId,
      Value<DateTime>? startTimestamp,
      Value<DateTime?>? endTimestamp,
      Value<bool>? active,
      Value<int>? userId}) {
    return TrackTableCompanion(
      id: id ?? this.id,
      trackId: trackId ?? this.trackId,
      startTimestamp: startTimestamp ?? this.startTimestamp,
      endTimestamp: endTimestamp ?? this.endTimestamp,
      active: active ?? this.active,
      userId: userId ?? this.userId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (trackId.present) {
      map['track_id'] = Variable<String>(trackId.value);
    }
    if (startTimestamp.present) {
      map['start_timestamp'] = Variable<DateTime>(startTimestamp.value);
    }
    if (endTimestamp.present) {
      map['end_timestamp'] = Variable<DateTime>(endTimestamp.value);
    }
    if (active.present) {
      map['active'] = Variable<bool>(active.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TrackTableCompanion(')
          ..write('id: $id, ')
          ..write('trackId: $trackId, ')
          ..write('startTimestamp: $startTimestamp, ')
          ..write('endTimestamp: $endTimestamp, ')
          ..write('active: $active, ')
          ..write('userId: $userId')
          ..write(')'))
        .toString();
  }
}

class TrackerSettingsTable extends Table
    with TableInfo<TrackerSettingsTable, TrackerSettingsTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  TrackerSettingsTable(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<bool> automaticTracking = GeneratedColumn<bool>(
      'automatic_tracking', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("automatic_tracking" IN (0, 1))'));
  late final GeneratedColumn<int> trackingFrequency = GeneratedColumn<int>(
      'tracking_frequency', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  late final GeneratedColumn<int> locationAccuracy = GeneratedColumn<int>(
      'location_accuracy', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  late final GeneratedColumn<int> minimumPointDistance = GeneratedColumn<int>(
      'minimum_point_distance', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  late final GeneratedColumn<int> pointsPerBatch = GeneratedColumn<int>(
      'points_per_batch', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  late final GeneratedColumn<String> deviceId = GeneratedColumn<String>(
      'device_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  late final GeneratedColumn<int> userId = GeneratedColumn<int>(
      'user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        automaticTracking,
        trackingFrequency,
        locationAccuracy,
        minimumPointDistance,
        pointsPerBatch,
        deviceId,
        userId
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'tracker_settings_table';
  @override
  Set<GeneratedColumn> get $primaryKey => {userId};
  @override
  TrackerSettingsTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TrackerSettingsTableData(
      automaticTracking: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}automatic_tracking']),
      trackingFrequency: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}tracking_frequency']),
      locationAccuracy: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}location_accuracy']),
      minimumPointDistance: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}minimum_point_distance']),
      pointsPerBatch: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}points_per_batch']),
      deviceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_id']),
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}user_id'])!,
    );
  }

  @override
  TrackerSettingsTable createAlias(String alias) {
    return TrackerSettingsTable(attachedDatabase, alias);
  }
}

class TrackerSettingsTableData extends DataClass
    implements Insertable<TrackerSettingsTableData> {
  final bool? automaticTracking;
  final int? trackingFrequency;
  final int? locationAccuracy;
  final int? minimumPointDistance;
  final int? pointsPerBatch;
  final String? deviceId;
  final int userId;
  const TrackerSettingsTableData(
      {this.automaticTracking,
      this.trackingFrequency,
      this.locationAccuracy,
      this.minimumPointDistance,
      this.pointsPerBatch,
      this.deviceId,
      required this.userId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || automaticTracking != null) {
      map['automatic_tracking'] = Variable<bool>(automaticTracking);
    }
    if (!nullToAbsent || trackingFrequency != null) {
      map['tracking_frequency'] = Variable<int>(trackingFrequency);
    }
    if (!nullToAbsent || locationAccuracy != null) {
      map['location_accuracy'] = Variable<int>(locationAccuracy);
    }
    if (!nullToAbsent || minimumPointDistance != null) {
      map['minimum_point_distance'] = Variable<int>(minimumPointDistance);
    }
    if (!nullToAbsent || pointsPerBatch != null) {
      map['points_per_batch'] = Variable<int>(pointsPerBatch);
    }
    if (!nullToAbsent || deviceId != null) {
      map['device_id'] = Variable<String>(deviceId);
    }
    map['user_id'] = Variable<int>(userId);
    return map;
  }

  TrackerSettingsTableCompanion toCompanion(bool nullToAbsent) {
    return TrackerSettingsTableCompanion(
      automaticTracking: automaticTracking == null && nullToAbsent
          ? const Value.absent()
          : Value(automaticTracking),
      trackingFrequency: trackingFrequency == null && nullToAbsent
          ? const Value.absent()
          : Value(trackingFrequency),
      locationAccuracy: locationAccuracy == null && nullToAbsent
          ? const Value.absent()
          : Value(locationAccuracy),
      minimumPointDistance: minimumPointDistance == null && nullToAbsent
          ? const Value.absent()
          : Value(minimumPointDistance),
      pointsPerBatch: pointsPerBatch == null && nullToAbsent
          ? const Value.absent()
          : Value(pointsPerBatch),
      deviceId: deviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceId),
      userId: Value(userId),
    );
  }

  factory TrackerSettingsTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TrackerSettingsTableData(
      automaticTracking: serializer.fromJson<bool?>(json['automaticTracking']),
      trackingFrequency: serializer.fromJson<int?>(json['trackingFrequency']),
      locationAccuracy: serializer.fromJson<int?>(json['locationAccuracy']),
      minimumPointDistance:
          serializer.fromJson<int?>(json['minimumPointDistance']),
      pointsPerBatch: serializer.fromJson<int?>(json['pointsPerBatch']),
      deviceId: serializer.fromJson<String?>(json['deviceId']),
      userId: serializer.fromJson<int>(json['userId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'automaticTracking': serializer.toJson<bool?>(automaticTracking),
      'trackingFrequency': serializer.toJson<int?>(trackingFrequency),
      'locationAccuracy': serializer.toJson<int?>(locationAccuracy),
      'minimumPointDistance': serializer.toJson<int?>(minimumPointDistance),
      'pointsPerBatch': serializer.toJson<int?>(pointsPerBatch),
      'deviceId': serializer.toJson<String?>(deviceId),
      'userId': serializer.toJson<int>(userId),
    };
  }

  TrackerSettingsTableData copyWith(
          {Value<bool?> automaticTracking = const Value.absent(),
          Value<int?> trackingFrequency = const Value.absent(),
          Value<int?> locationAccuracy = const Value.absent(),
          Value<int?> minimumPointDistance = const Value.absent(),
          Value<int?> pointsPerBatch = const Value.absent(),
          Value<String?> deviceId = const Value.absent(),
          int? userId}) =>
      TrackerSettingsTableData(
        automaticTracking: automaticTracking.present
            ? automaticTracking.value
            : this.automaticTracking,
        trackingFrequency: trackingFrequency.present
            ? trackingFrequency.value
            : this.trackingFrequency,
        locationAccuracy: locationAccuracy.present
            ? locationAccuracy.value
            : this.locationAccuracy,
        minimumPointDistance: minimumPointDistance.present
            ? minimumPointDistance.value
            : this.minimumPointDistance,
        pointsPerBatch:
            pointsPerBatch.present ? pointsPerBatch.value : this.pointsPerBatch,
        deviceId: deviceId.present ? deviceId.value : this.deviceId,
        userId: userId ?? this.userId,
      );
  TrackerSettingsTableData copyWithCompanion(
      TrackerSettingsTableCompanion data) {
    return TrackerSettingsTableData(
      automaticTracking: data.automaticTracking.present
          ? data.automaticTracking.value
          : this.automaticTracking,
      trackingFrequency: data.trackingFrequency.present
          ? data.trackingFrequency.value
          : this.trackingFrequency,
      locationAccuracy: data.locationAccuracy.present
          ? data.locationAccuracy.value
          : this.locationAccuracy,
      minimumPointDistance: data.minimumPointDistance.present
          ? data.minimumPointDistance.value
          : this.minimumPointDistance,
      pointsPerBatch: data.pointsPerBatch.present
          ? data.pointsPerBatch.value
          : this.pointsPerBatch,
      deviceId: data.deviceId.present ? data.deviceId.value : this.deviceId,
      userId: data.userId.present ? data.userId.value : this.userId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TrackerSettingsTableData(')
          ..write('automaticTracking: $automaticTracking, ')
          ..write('trackingFrequency: $trackingFrequency, ')
          ..write('locationAccuracy: $locationAccuracy, ')
          ..write('minimumPointDistance: $minimumPointDistance, ')
          ..write('pointsPerBatch: $pointsPerBatch, ')
          ..write('deviceId: $deviceId, ')
          ..write('userId: $userId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(automaticTracking, trackingFrequency,
      locationAccuracy, minimumPointDistance, pointsPerBatch, deviceId, userId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TrackerSettingsTableData &&
          other.automaticTracking == this.automaticTracking &&
          other.trackingFrequency == this.trackingFrequency &&
          other.locationAccuracy == this.locationAccuracy &&
          other.minimumPointDistance == this.minimumPointDistance &&
          other.pointsPerBatch == this.pointsPerBatch &&
          other.deviceId == this.deviceId &&
          other.userId == this.userId);
}

class TrackerSettingsTableCompanion
    extends UpdateCompanion<TrackerSettingsTableData> {
  final Value<bool?> automaticTracking;
  final Value<int?> trackingFrequency;
  final Value<int?> locationAccuracy;
  final Value<int?> minimumPointDistance;
  final Value<int?> pointsPerBatch;
  final Value<String?> deviceId;
  final Value<int> userId;
  const TrackerSettingsTableCompanion({
    this.automaticTracking = const Value.absent(),
    this.trackingFrequency = const Value.absent(),
    this.locationAccuracy = const Value.absent(),
    this.minimumPointDistance = const Value.absent(),
    this.pointsPerBatch = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.userId = const Value.absent(),
  });
  TrackerSettingsTableCompanion.insert({
    this.automaticTracking = const Value.absent(),
    this.trackingFrequency = const Value.absent(),
    this.locationAccuracy = const Value.absent(),
    this.minimumPointDistance = const Value.absent(),
    this.pointsPerBatch = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.userId = const Value.absent(),
  });
  static Insertable<TrackerSettingsTableData> custom({
    Expression<bool>? automaticTracking,
    Expression<int>? trackingFrequency,
    Expression<int>? locationAccuracy,
    Expression<int>? minimumPointDistance,
    Expression<int>? pointsPerBatch,
    Expression<String>? deviceId,
    Expression<int>? userId,
  }) {
    return RawValuesInsertable({
      if (automaticTracking != null) 'automatic_tracking': automaticTracking,
      if (trackingFrequency != null) 'tracking_frequency': trackingFrequency,
      if (locationAccuracy != null) 'location_accuracy': locationAccuracy,
      if (minimumPointDistance != null)
        'minimum_point_distance': minimumPointDistance,
      if (pointsPerBatch != null) 'points_per_batch': pointsPerBatch,
      if (deviceId != null) 'device_id': deviceId,
      if (userId != null) 'user_id': userId,
    });
  }

  TrackerSettingsTableCompanion copyWith(
      {Value<bool?>? automaticTracking,
      Value<int?>? trackingFrequency,
      Value<int?>? locationAccuracy,
      Value<int?>? minimumPointDistance,
      Value<int?>? pointsPerBatch,
      Value<String?>? deviceId,
      Value<int>? userId}) {
    return TrackerSettingsTableCompanion(
      automaticTracking: automaticTracking ?? this.automaticTracking,
      trackingFrequency: trackingFrequency ?? this.trackingFrequency,
      locationAccuracy: locationAccuracy ?? this.locationAccuracy,
      minimumPointDistance: minimumPointDistance ?? this.minimumPointDistance,
      pointsPerBatch: pointsPerBatch ?? this.pointsPerBatch,
      deviceId: deviceId ?? this.deviceId,
      userId: userId ?? this.userId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (automaticTracking.present) {
      map['automatic_tracking'] = Variable<bool>(automaticTracking.value);
    }
    if (trackingFrequency.present) {
      map['tracking_frequency'] = Variable<int>(trackingFrequency.value);
    }
    if (locationAccuracy.present) {
      map['location_accuracy'] = Variable<int>(locationAccuracy.value);
    }
    if (minimumPointDistance.present) {
      map['minimum_point_distance'] = Variable<int>(minimumPointDistance.value);
    }
    if (pointsPerBatch.present) {
      map['points_per_batch'] = Variable<int>(pointsPerBatch.value);
    }
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TrackerSettingsTableCompanion(')
          ..write('automaticTracking: $automaticTracking, ')
          ..write('trackingFrequency: $trackingFrequency, ')
          ..write('locationAccuracy: $locationAccuracy, ')
          ..write('minimumPointDistance: $minimumPointDistance, ')
          ..write('pointsPerBatch: $pointsPerBatch, ')
          ..write('deviceId: $deviceId, ')
          ..write('userId: $userId')
          ..write(')'))
        .toString();
  }
}

class DatabaseAtV5 extends GeneratedDatabase {
  DatabaseAtV5(QueryExecutor e) : super(e);
  late final UserTable userTable = UserTable(this);
  late final UserSettingsTable userSettingsTable = UserSettingsTable(this);
  late final PointGeometryTable pointGeometryTable = PointGeometryTable(this);
  late final PointPropertiesTable pointPropertiesTable =
      PointPropertiesTable(this);
  late final PointsTable pointsTable = PointsTable(this);
  late final TrackTable trackTable = TrackTable(this);
  late final TrackerSettingsTable trackerSettingsTable =
      TrackerSettingsTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
        userTable,
        userSettingsTable,
        pointGeometryTable,
        pointPropertiesTable,
        pointsTable,
        trackTable,
        trackerSettingsTable
      ];
  @override
  int get schemaVersion => 5;
}
